crystal_doc_search_index_callback({"repository_name":"","body":"# struct-mappings\n\n#### Generate crystal classes mapping C structures.\n\n[![Docs](https://img.shields.io/badge/docs-available-brightgreen.svg)](https://elbywan.github.io/struct-mappings/)\n[![GitHub release](https://img.shields.io/github/release/elbywan/struct-mappings.svg)](https://github.com/elbywan/struct-mappings/releases)\n[![Build Status](https://travis-ci.org/elbywan/struct-mappings.svg?branch=master)](https://travis-ci.org/elbywan/struct-mappings)\n\n## Purpose\n\n`struct-mappings` exposes useful macros that can be used to convert a [C struct](https://crystal-lang.org/reference/syntax_and_semantics/c_bindings/struct.html) into a Crystal class and vice versa.\n\nThe inner representation of the data is a [NamedTuple](https://crystal-lang.org/api/latest/NamedTuple.html) which is very convenient to use.\n\n## Utility\n\nConversion from & to a C structure could be useful in the following scenarios:\n\n- Persisting data that would get freed otherwise when calling an external library.\n- Avoiding calling `.value` on nested structure pointers.\n- C structs are arguably less convenient to use compared to named tuples.\n\n## Features\n\n- Supports nested structures.\n- Automatically allocates & dereference structure pointers.\n- C structures containing array pointers can be converted to an array wrapper class.\n- Conversion can be customized.\n\n## Installation\n\n1. Add the dependency to your `shard.yml`:\n\n   ```yaml\n   dependencies:\n     struct-mappings:\n       github: elbywan/struct-mappings\n   ```\n\n2. Run `shards install`\n\n## Usage\n\n#### Require\n\n```crystal\nrequire \"struct-mappings\"\n```\n\n#### Minimal use case\n\n```crystal\n# Include the Mappings module\ninclude Mappings\n\n# Define a dummy structure.\nlib C\n  struct Data\n    int: LibC::Int\n  end\nend\n\n# Map this structure to a crystal class.\nstruct_mapping Data, C::Data,\n  int : Int32\n\n# The class can be instantiated from a named tuple containing the fields…\ndata = Data.new({int: 10})\n# or directly from the C structure.\ndata_from_c = Data.new(\n  C::Data.new int: 10\n)\n# The two classes hold the same data.\npp data == data_from_c # => true\n# And it can be converted back using the `to_unsafe` method.\npp data.to_unsafe # => C::Data(@int=10)\n\n# For structures that represent arrays, it's also quite simple.\n\n# Define a dummy array.\nlib C\n  struct DataArray\n    data: Data*\n    size: LibC::Int\n  end\nend\n\n# Map the array to a crystal class.\n# Generates a `DataArray` class which is a wrapper around\n# an Array of `Data` classes, and mapping the `C::DataArray` struct.\nstruct_array_mapping DataArray, Data, C::DataArray\n\n# Can be instantiated from a crystal array…\narray_from_data = DataArray.new [\n  Data.new({int: 10}),\n  Data.new({int: 20}),\n]\npp array_from_data # => [{int: 10}, {int: 20}]\n\n# or a C structure representation.\narray_from_c = DataArray.new C::DataArray.new(\n  size: 2,\n  data: [\n    C::Data.new(int: 10),\n    C::Data.new(int: 20),\n  ].to_unsafe\n)\npp array_from_c # => [{int: 10}, {int: 20}]\n\n# The two classes hold the same data.\npp array_from_data == array_from_c # => true\n\n# And it can be converted back using the `to_unsafe` method.\npp array_from_data.to_unsafe # => C::DataArray(@data=Pointer(C::Data)@0x10e1cfda0, @size=2)\n```\n\n## Documentation\n\nThe exhaustive documentation is hosted [here](https://elbywan.github.io/struct-mappings).\n\n## Development\n\nTODO: Write development instructions here\n\n## Contributing\n\n1. Fork it (<https://github.com/your-github-user/struct-mappings/fork>)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n\n## Contributors\n\n- [elbywan](https://github.com/your-github-user) - creator and maintainer\n","program":{"html_id":"/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"","program":true,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"/Mappings","path":"Mappings.html","kind":"module","full_name":"Mappings","name":"Mappings","abstract":false,"superclass":null,"ancestors":[{"html_id":"/Mappings/Utils","kind":"module","full_name":"Mappings::Utils","name":"Utils"}],"locations":[],"repository_name":"","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[{"html_id":"/Mappings/Utils","kind":"module","full_name":"Mappings::Utils","name":"Utils"}],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[{"id":"struct_array_mapping(class_name,of_class,struct_name,dbl_ptr=false,from_data=nil,from_c=nil,to_c=nil,size_field=size,data_field=data,size_type=nil)-macro","html_id":"struct_array_mapping(class_name,of_class,struct_name,dbl_ptr=false,from_data=nil,from_c=nil,to_c=nil,size_field=size,data_field=data,size_type=nil)-macro","name":"struct_array_mapping","doc":"Generates a class mapping a C structure representing an array of elements.\n\n#### Overview\n\nAn array representation should contain the following fields:\n- a pointer to the first element in the array.\n- a number, the size of the array.\n\nIn practice, the created class is a wrapper around an Array holding the data.\n`initialize` methods are provided for instantiating the class from an array or a C structure\nand `to_unsafe` converts the data into a C structure representation.\n\n#### Usage\n\nCall `struct_array_mapping` with:\n\n1. The class name that is going to be generated.\n2. The type of elements in the array.\n3. The mapped C structure.\n4. Additional arguements.\n\n```\n# Include the Mappings module\ninclude Mappings\n\n# Define dummy structures.\nlib C\n  struct Data\n    int : LibC::Int\n  end\n\n  struct DataArray\n    data : Data*\n    size : Int32\n  end\nend\n\n# Map the structure to a crystal class.\nstruct_mapping Data, C::Data,\n  int : Int32\n\n# Map the array structure to a crystal class.\nstruct_array_mapping DataArray, Data, C::DataArray\n\n# The class can be instantiated from an array of crystal classes…\ndata_array = DataArray.new [\n  Data.new({int: 10}),\n  Data.new({int: 20}),\n]\n# or directly from the C structure.\ndata_array_from_c = DataArray.new C::DataArray.new(\n  size: 2,\n  data: [\n    C::Data.new(int: 10),\n    C::Data.new(int: 20),\n  ]\n)\n\n# The two classes hold the same data.\npp data_array == data_array_from_c # => true\n# And it can be converted back using the `to_unsafe` method.\npp data_array.to_unsafe\n# => C::DataArray(\n#      @data=Pointer(C::Data)@0x1052c5e10,\n#      @size=2)\n```\n\n#### Additional arguments\n\n- dbl_ptr (default: false)\n\nSet `dbl_ptr` to true if the c structure represents an array of structure pointers.\n\n- size_field (default: size)\n\nUsed to identify the structure field name that contains the size of the array.\n\n- data_field (default: data)\n\nUsed to identify the structure field name that contains the array pointer.\n\n- from_data\n\nCustomize the behaviour when setting the internal data representation field from a crystal array.\n\n- from_c\n\nCustomize the behaviour when setting the internal data representation field from a structure argument.\n\n- to_c\n\nCustomize the behaviour when setting the C structure field from the internal data representation.\n\n```\nlib C\n  struct S\n    field : Int32\n  end\n\n  struct SArray\n    data : S*\n    size : LibC::Int\n  end\nend\n\nstruct_mapping S, C::S, field : Int32\n# Let's change the default beaviour using the `from_data`, `to_data` and `to_c` functions.\n# For all these methods, `elt` is an element of the source array.\nstruct_array_mapping SArray, S, C::SArray,\n  # Here, we allow an SArray to be initialized with a plain array of integers.\n  from_data: S.new({field: elt}),\n  # Here, we substract one when initializing from a C structure.\n  from_c: S.new({field: elt.field - 1}),\n  # And we add one when converting into a C structure.\n  to_c: C::S.new field: elt.field + 1\n\npp SArray.new [0, 1, 2]\n# => [{field: 0}, {field: 1}, {field: 2}]\npp SArray.new(\n  C::SArray.new size: 3, data: [\n    C::S.new(field: 1),\n    C::S.new(field: 2),\n    C::S.new(field: 3),\n  ].to_unsafe\n)\n# => [{field: 0}, {field: 1}, {field: 2}]\npp SArray.new([0, 1, 2]).to_unsafe\n# => C::SArray(@data=Pointer(C::S)@0x108cbfd60, @size=3)\n```","summary":"<p>Generates a class mapping a C structure representing an array of elements.</p>","abstract":false,"args":[{"name":"class_name","doc":null,"default_value":"","external_name":"class_name","restriction":""},{"name":"of_class","doc":null,"default_value":"","external_name":"of_class","restriction":""},{"name":"struct_name","doc":null,"default_value":"","external_name":"struct_name","restriction":""},{"name":"dbl_ptr","doc":null,"default_value":"false","external_name":"dbl_ptr","restriction":""},{"name":"from_data","doc":null,"default_value":"nil","external_name":"from_data","restriction":""},{"name":"from_c","doc":null,"default_value":"nil","external_name":"from_c","restriction":""},{"name":"to_c","doc":null,"default_value":"nil","external_name":"to_c","restriction":""},{"name":"size_field","doc":null,"default_value":"size","external_name":"size_field","restriction":""},{"name":"data_field","doc":null,"default_value":"data","external_name":"data_field","restriction":""},{"name":"size_type","doc":null,"default_value":"nil","external_name":"size_type","restriction":""}],"args_string":"(class_name, of_class, struct_name, dbl_ptr = <span class=\"n\">false</span>, from_data = <span class=\"n\">nil</span>, from_c = <span class=\"n\">nil</span>, to_c = <span class=\"n\">nil</span>, size_field = size, data_field = data, size_type = <span class=\"n\">nil</span>)","source_link":null,"def":{"name":"struct_array_mapping","args":[{"name":"class_name","doc":null,"default_value":"","external_name":"class_name","restriction":""},{"name":"of_class","doc":null,"default_value":"","external_name":"of_class","restriction":""},{"name":"struct_name","doc":null,"default_value":"","external_name":"struct_name","restriction":""},{"name":"dbl_ptr","doc":null,"default_value":"false","external_name":"dbl_ptr","restriction":""},{"name":"from_data","doc":null,"default_value":"nil","external_name":"from_data","restriction":""},{"name":"from_c","doc":null,"default_value":"nil","external_name":"from_c","restriction":""},{"name":"to_c","doc":null,"default_value":"nil","external_name":"to_c","restriction":""},{"name":"size_field","doc":null,"default_value":"size","external_name":"size_field","restriction":""},{"name":"data_field","doc":null,"default_value":"data","external_name":"data_field","restriction":""},{"name":"size_type","doc":null,"default_value":"nil","external_name":"size_type","restriction":""}],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"    class \n{{ class_name }}\n < StructArrayMapping\n    Mappings.base_mapping Array(\n{{ of_class }}\n) do\n        \n{% if from_data %}\n          @data = data.map do |elt|\n            {{ from_data }}\n          end\n        {% else %}\n          @data = data.map do |elt|\n            {{ of_class }}.new elt\n          end\n        {% end %}\n\n      \nend\n\n      \n# Create a new \n{{ class_name }}\n instance from a \n{{ struct_name }}\n structure.\n\n      def initialize(c_data : \n{{ struct_name }}\n)\n        size = c_data.\n{{ size_field }}\n\n        @data = Array(\n{{ of_class }}\n).new(\n          size || 0\n        )\n        if c_data.\n{{ data_field }}\n\n          (0...size).each do |i|\n            \nelt = c_data.\n{{ data_field }}\n[i]\n            \n%to_push\n = (\n              \n{% if from_c %}{{ from_c }}{% else %}{% if dbl_ptr %}{{ of_class }}.new elt.value{% else %}{{ of_class }}.new elt{% end %}{% end %}\n\n            )\n            @data << \n%to_push\n\n          \nend\n        \nelse\n          @data = [] of \n{{ of_class }}\n\n        \nend\n      \nend\n\n      \n# Returns a mapped \n{{ struct_name }}\n structure suitable for use in C bindings.\n\n      def to_unsafe\n        \n{{ struct_name }}\n.new(\n          \n{{ data_field }}\n: @data.map do |elt|\n            \n{% if to_c %}\n              {{ to_c }}\n            {% else %}{% if dbl_ptr %}\n              ptr_alloc elt.to_unsafe\n            {% else %}\n              elt.to_unsafe\n            {% end %}{% end %}\n\n          \nend,\n          \n{{ size_field }}\n: \n{% if size_type %}{{ size_type }}.new {% end %}\n@data.size\n        )\n      \nend\n    \nend\n  \n"}},{"id":"struct_mapping(class_name,struct_name,*args)-macro","html_id":"struct_mapping(class_name,struct_name,*args)-macro","name":"struct_mapping","doc":"Generates a class mapping a C structure.\n\n#### Overview\n\nIn practice, the created class is a wrapper around a named tuple holding the data.\n`initialize` methods are provided for instantiating the class from a tuple or a C structure\nand `to_unsafe` converts the data into C struct representation.\n\nThe conversion is recursive, and will attempt to dereference structure pointers\nwhich is handy in case of nested structures.\n\n#### Usage\n\nCall `struct_mapping` with:\n\n1. The class name that is going to be generated.\n2. The mapped C structure.\n3. The fields that the structure contains.\n\n```\n# Include the Mappings module\ninclude Mappings\n\n# Define a dummy structure.\nlib C\n  struct Data\n    int : LibC::Int\n  end\nend\n\n# Map this structure to a crystal class.\nstruct_mapping Data, C::Data,\n  int : Int32\n\n# The class can be instantiated from a named tuple containing the fields…\ndata = Data.new({int: 10})\n# or directly from the C structure.\ndata_from_c = Data.new(\n  C::Data.new int: 10\n)\n# The two classes hold the same data.\npp data == data_from_c # => true\n# And it can be converted back using the `to_unsafe` method.\npp data.to_unsafe # => C::Data(@int=10)\n```\n\n#### Field options\n\n- ptr\n\nUse `ptr: true` to specify that the field contains a pointer to a nested structure.\n\n```\nlib C\n  struct S\n    # A nested structure\n    nested : N\n    # A pointer to a nested structure\n    nested_ptr : N*\n  end\n\n  struct N\n    int : LibC::Int\n  end\nend\n\nstruct_mapping N, C::N, int : Int32\n\nstruct_mapping S, C::S,\n  nested : N,\n  # Declare this field as a pointer.\n  nested_ptr : N = {ptr: true}\n\ns = S.new(C::S.new(\n  nested: C::N.new(int: 1),\n  nested_ptr: Pointer.malloc(sizeof(C::N), C::N.new int: 2)\n))\n\n# Both nested structures are converted into a nested named tuple.\npp s\n# => {nested: {int: 1}, nested_ptr: {int: 2}}\n\n# Here a pointer is allocated for the nested structure.\npp s.to_unsafe\n# => C::S(@nested=C::N(@int=1), @nested_ptr=Pointer(C::N)@0x10fc64f20)\n```\n\n- from_data\n\nCustomize the behaviour when setting the internal data representation field from a tuple argument.\n\n- from_c\n\nCustomize the behaviour when setting the internal data representation field from a structure argument.\n\n- to_c\n\nCustomize the behaviour when setting the C structure field from the internal data representation.\n\n```\nlib C\n  struct S\n    field : Int32\n  end\nend\n\nstruct_mapping S, C::S,\n  # Here, the crystal representation is a String, whereas the C representation is an integer.\n  # We are using the custom behaviour methods as adapters.\n  field : String = {\n    # data: the initialize function argument (named tuple)\n    from_data: data[\"field\"].to_s,\n    # c_data: the initialize function argument (c structure)\n    from_c: c_data.field.to_s,\n    # [field name]: shortcut for @data[\"field name\"], @data being the internal representation.\n    to_c: field.to_i32,\n  }\n\npp S.new({field: 20})           # {field: \"20\"}\npp S.new(C::S.new field: 20)    # {field: \"20\"}\npp S.new({field: 20}).field     # \"20\"\npp S.new({field: 20}).to_unsafe # C::S(@field=20)\n```","summary":"<p>Generates a class mapping a C structure.</p>","abstract":false,"args":[{"name":"class_name","doc":null,"default_value":"","external_name":"class_name","restriction":""},{"name":"struct_name","doc":null,"default_value":"","external_name":"struct_name","restriction":""},{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(class_name, struct_name, *args)","source_link":null,"def":{"name":"struct_mapping","args":[{"name":"class_name","doc":null,"default_value":"","external_name":"class_name","restriction":""},{"name":"struct_name","doc":null,"default_value":"","external_name":"struct_name","restriction":""},{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":null,"splat_index":2,"block_arg":null,"visibility":"Public","body":"    class \n{{ class_name }}\n < StructMapping\n      alias DataType = \n{\n        \n{% for arg in args %}{{ arg.var }}: {{ arg.type }},{% end %}\n\n      }\n\n      \n{% for arg in args %}\n      def {{ arg.var }}\n        @data[\"{{ arg.var }}\"]\n      end\n      {% end %}\n\n\n      Mappings.base_mapping DataType do\n        @data = \n{\n          \n{% for arg in args %}\n            {% if arg.value && arg.value[\"from_data\"] %}\n              # Custom\n              {{ arg.var }}: {{ arg.value[\"from_data\"] }},\n            {% else %}{% if arg.type.resolve.union_types.any? do |t|\n  t < StructMapping || t < StructArrayMapping\nend %}\n              # Mapping\n              {% if arg.type.resolve.nilable? %}\n                {{ arg.var }}: data[\"{{ arg.var }}\"].try { |v| {{ arg.type.resolve.union_types.find do |t|\n  t != Nil\nend }}.new(v) },\n              {% else %}\n                {{ arg.var }}: {{ arg.type }}.new(data[\"{{ arg.var }}\"]),\n              {% end %}\n            {% else %}\n              # Default\n              {{ arg.var }}: data[\"{{ arg.var }}\"],\n            {% end %}{% end %}\n          {% end %}\n\n        }\n      \nend\n\n      \n# Create a new \n{{ class_name }}\n instance from a \n{{ struct_name }}\n structure.\n\n      def initialize(c_data : \n{{ struct_name }}\n)\n          @data = \n{\n            \n{% for arg in args %}\n              {% if arg.value && arg.value[\"from_c\"] %}\n                # Custom\n                {{ arg.var }}: {{ arg.value[\"from_c\"] }},\n              {% else %}{% if arg.type.resolve.union_types.any? do |t|\n  t < StructMapping || t < StructArrayMapping\nend %}\n                {% if arg.type.resolve.nilable? %}\n                  {{ arg.var }}: ({{ arg.type.resolve.union_types.find do |t|\n  t != Nil\nend }}.new(c_data.{{ arg.var }}{% if arg.value && arg.value[\"ptr\"] %}.value{% end %}) if c_data.{{ arg.var }}),\n                {% else %}\n                  {{ arg.var }}: {{ arg.type }}.new(c_data.{{ arg.var }}{% if arg.value && arg.value[\"ptr\"] %}.value{% end %}),\n                {% end %}\n              {% else %}{% if arg.type.resolve.union_types.includes?(Bool) %}\n                # Core value types\n                {{ arg.var }}: c_data.{{ arg.var }} == 1,\n              {% else %}{% if arg.type.resolve.union_types.includes?(String) %}\n                # Core reference types\n                {% if arg.type.resolve.nilable? %}\n                  {{ arg.var }}: ptr_to_string?(c_data.{{ arg.var }}),\n                {% else %}\n                  {{ arg.var }}: ptr_to_string(c_data.{{ arg.var }}),\n                {% end %}\n              {% else %}\n                # Default\n                {{ arg.var }}: c_data.{{ arg.var }},\n              {% end %}{% end %}{% end %}{% end %}\n            {% end %}\n\n          }\n      \nend\n\n      \n# Returns a mapped \n{{ struct_name }}\n structure suitable for use in C bindings.\n\n      def to_unsafe\n          c_data = \n{{ struct_name }}\n.new\n\n          \n{% for arg in args %}\n            {% if arg.value && arg.value[\"to_c\"] %}\n              # Custom\n              Mappings::Utils.assign {{ arg.var }} do\n                {{ arg.value[\"to_c\"] }}\n              end\n            {% else %}{% if (arg.type.resolve.union_types.any? do |t|\n  t < StructMapping || t < StructArrayMapping\nend && arg.value) && arg.value[\"ptr\"] %}\n              # Mapping pointer\n              Mappings::Utils.assign {{ arg.var }} do\n                ptr_alloc({{ arg.var }}.to_unsafe)\n              end\n            {% else %}{% if arg.type.resolve.union_types.includes?(Bool) %}\n              # Core value types\n              Mappings::Utils.assign_bool {{ arg.var }}\n            {% else %}\n              # Default\n              Mappings::Utils.assign {{ arg.var }}\n            {% end %}{% end %}{% end %}\n          {% end %}\n\n\n          c_data\n      \nend\n    \nend\n  \n"}}],"types":[]}]}})